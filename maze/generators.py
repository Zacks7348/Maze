"""
This file contains different maze generation algorithms. Each algorithm is
wrapped in a subclass of MazeGenerator. 

These algorithms are implemented such that they can be stepped through or ran
all in one go. The algorithms implemented are:
    
- Randomized Depth-First Search
    - Implemented in the RDFSMazeGenerator class
- Randomized Prim's Algorithm
    - Implemented in the RPAMazeGenerator class

A maze can be generated by creating an object of one of these classes.
Arguments for the generator can be passed to the constructor. See the
base MazeGenerator class for what arguments can be sent. Once generation
is complete you can access the created Maze object through the maze attribute

Generators can be ran in 2 modes: 
- Default
    The algorithm runs all at once when the class object is initialized
- Step
    Each iteration of the algorithm is performed when the step() function
    is called. A boolean attribute finished is set to True when the algorithm
    finishes.
"""

import random

from maze.maze import Maze, Cell, CellType

class MazeGenMethods:
    RDFS = 'RDFS'
    RPA = "RPA"

class MazeGenerator:
    """
    Base class for Maze generators

    THIS CLASS DOES NOT PEFORM GENERATION. 
    
    Instead, this class is meant to be subclassed 
    and provides common functionality and input checking
    """
    def __init__(self, **kwargs) -> None:
        """
        Initializes a maze generator class. 

        Keyword Arguments
        -----------------
        step: bool, default=False
            If True, then the generation algorithm will run in step mode
        height: int, default=105
            The height of the maze. The height must be an odd integer larger than 3
        width: int, default=105
            The width of the maze. The width must be an odd integer larger than 3
        """
        self.maze: Maze = None
        self.step_mode = kwargs.pop('step', False)
        self.height = kwargs.pop('height', 105)
        if self.height % 2 == 0 or self.height <= 3 or not isinstance(self.height, int):
            raise ValueError('Maze height must be an odd integer larger than 3')
        self.width = kwargs.pop('width', 105)
        if self.width % 2 == 0 or self.width <= 3 or not isinstance(self.width, int):
            raise ValueError('Maze width must be an odd integer larger than 3')
        self.frontier = None
        self.finished = False

    def randomized_start_finish(self):
        """
        Randomly choose a start and finish cell and set them in the maze
        """

        s = self.random_cell(self.maze.height, self.maze.width, is_odd=True)
        while self.maze.is_wall(s):
            s = self.random_cell(self.maze.height, self.maze.width, is_odd=True)
        self.maze.start_pos = s
        self.maze.set(s, CellType.START)

        f = self.random_cell(self.maze.height, self.maze.width, is_odd=True)
        while self.maze.is_wall(f) or f == self.maze.start_pos:
            f = self.random_cell(self.maze.height, self.maze.width, is_odd=True)
        self.maze.finish_pos = f
        self.maze.set(f, CellType.FINISH)
    
    def random_cell(self, max_row: int, max_col: int, is_odd: bool = False) -> Cell:
        """
        Utility function that randomly chooses a cell

        Parameters
        ----------
        max_row: int
            The exclusive max row number of the cell
        max_col: int
            The exclusive max col number of the cell
        is_odd: bool, default=False
            If True, only choose cells with odd row and col values
        
        Returns
        -------
        Cell
            The randomly chosen cell as a Cell object
        """
        row = random.randint(0, max_row-1)
        while is_odd and row % 2 == 0:
            row = random.randint(0, max_row-1)
        col = random.randint(0, max_col-1)
        while is_odd and col % 2 == 0:
            col = random.randint(0, max_col-1)
        return Cell(row, col)

    def middle_cell(self, c1: Cell, c2: Cell) -> Cell:
        """
        Utility function that returns the cell in the middle
        of c1 and c2
        """
        if c1.row == c2.row:
            return Cell(c1.row, max(c1.col, c2.col)-1)
        return Cell(max(c1.row, c2.row)-1, c1.col)
    
    def opposite_cell(self, cell: Cell, n: Cell):
        """
        Utility function that returns the cell on the opposite side
        of cell from n
        """
        dr = cell.row - n.row
        row = dr + min(cell.row, n.row) if dr < 0 else dr + max(cell.row, n.row)
        dc = cell.col - n.col
        col = dc + min(cell.col, n.col) if dc < 0 else dc + max(cell.col, n.col)
        return Cell(row, col)
    
    def loopify(self, chance=0.1) -> None:
        """
        Adds loops to the maze by deleting walls seperating two passages.

        Parameters
        ----------
        chance: float, default=0.1
            The chance that a wall is deleted
        """
        if not 0 <= chance <= 1:
            raise ValueError('Loop chance must be a number between 0 and 1!')
        changed = []
        for i in range(2, self.maze.height-2, 2):
            for j in range(2, self.maze.width-2, 2):
                c = Cell(i, j)
                if self.maze.is_wall(c) and random.random() < chance:
                    for n in self.maze.get_neighboring_passages(c):
                        o = self.opposite_cell(c, n)
                        if self.maze.is_passage(o):
                            self.maze.set(c, CellType.PASSAGE)
                            changed.append(c)
                            break
        return changed

class RDFSMazeGenerator(MazeGenerator):
    """
    Maze Generator using Randomized Depth-First Search
    """

    def __init__(self, **kwargs) -> None:
        """
        Initializes the RDFS generator. All keyword arguments are
        sent to the :class:`MazeGenerator` constructor.  
        """
        super().__init__(**kwargs)

        # Initialize maze as a grid of walls
        m = [[CellType.WALL for _ in range(
            self.width)] for _ in range(self.height)]

        self.maze = Maze(m)
        self.frontier = []

        # Randomly choose starting point
        start = self.random_cell(self.height, self.width, is_odd=True)
        self.frontier.append(start)

        if self.step_mode:
            return
        while not self.finished:
            self.step()
    
    def step(self):
        """
        Each call to this function will execute a single iteration of the algorithm.
        It is recommended to continually call this function in a loop while the finished
        attribute is False.
        """
        if not self.frontier:
            # Finished
            self.finished = True
            return None
        cell = self.frontier[-1]
        neighbors = self.maze.get_neighboring_walls(cell, d=2)
        if neighbors:
            n = random.choice(neighbors)
            #self.maze.set(cell, CellType.PASSAGE)
            self.maze.set(n, CellType.PASSAGE)
            middle = self.middle_cell(cell, n)
            self.maze.set(middle, CellType.PASSAGE)
            self.frontier.append(n)
            return (middle, n)
        else:
            self.frontier.pop()
        return None

class RPAMazeGenerator(MazeGenerator):
    """
    Maze Generator using Randomized Prim's Algorithm
    """
    def __init__(self, **kwargs) -> None:
        """
        Initializes the RPA generator. All keyword arguments are
        sent to the :class:`MazeGenerator` constructor.  
        """
        super().__init__(**kwargs)
        
        # Initialize maze as a grid of walls
        m = [[CellType.WALL for _ in range(
            self.width)] for _ in range(self.height)]
        
        self.maze = Maze(m)
        self.frontier = []
        self.frontier_set = set()

        start = self.random_cell(self.height, self.width, is_odd=True)
        self.maze.set(start, CellType.PASSAGE)
        for n in self.maze.get_neighboring_walls(start, d=2):
            self.frontier.append(n)
            self.frontier_set.add(n)

        if self.step_mode:
            return
        while not self.finished:
            self.step()
    
    def step(self):
        """
        Each call to this function will execute a single iteration of the algorithm.
        It is recommended to continually call this function in a loop while the finished
        attribute is False.
        """
        def add(c1, c2, c3):
            self.maze.set(c1, CellType.PASSAGE)
            self.maze.set(c2, CellType.PASSAGE)
            self.maze.set(c3, CellType.PASSAGE)

            for tmp in self.maze.get_neighboring_walls(c1, d=2):
                if not tmp in self.frontier_set:
                    self.frontier.append(tmp)
                    self.frontier_set.add(tmp)

        if not self.frontier:
            self.finished = True
            return None
        wall = self.frontier.pop(random.randint(0, len(self.frontier)-1))
        self.frontier_set.remove(wall)
        neighbors = self.maze.get_neighboring_cells(wall, d=2)
        random.shuffle(neighbors)
        for n in neighbors:
            if self.maze.is_passage(n):
                middle = self.middle_cell(wall, n)
                add(wall, middle, n)
                return (wall, middle, n)
        return None
